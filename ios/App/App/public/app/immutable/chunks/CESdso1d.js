const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DD521F7X.js","./DOsK5eWY.js"])))=>i.map(i=>d[i]);
import{g as b,f as u,h as E,q as w,e as p,w as m,i as x,o as L,l as I,j as C,d as R,u as A}from"./DuaF19nW.js";import{_ as T}from"./Dp1pzeXC.js";import{r as U}from"./DOsK5eWY.js";var v;(function(o){o.Documents="DOCUMENTS",o.Data="DATA",o.Library="LIBRARY",o.Cache="CACHE",o.External="EXTERNAL",o.ExternalStorage="EXTERNAL_STORAGE"})(v||(v={}));var _;(function(o){o.UTF8="utf8",o.ASCII="ascii",o.UTF16="utf16"})(_||(_={}));const B=U("Filesystem",{web:()=>T(()=>import("./DD521F7X.js"),__vite__mapDeps([0,1]),import.meta.url).then(o=>new o.FilesystemWeb)}),O=()=>typeof window.Capacitor<"u",P="vibewise-local",h="audio-recordings",M=1;let S=null;const F=()=>S||(S=new Promise((o,s)=>{const e=indexedDB.open(P,M);e.onerror=t=>{console.error("Error opening IndexedDB:",t),s(new Error("Could not open IndexedDB"))},e.onsuccess=t=>{o(t.target.result)},e.onupgradeneeded=t=>{const r=t.target.result;r.objectStoreNames.contains(h)||r.createObjectStore(h,{keyPath:"id"})}}),S),N=async(o,s,e)=>{try{const a=(await F()).transaction([h],"readwrite").objectStore(h),n={id:e,userId:o,blob:s,timestamp:Date.now(),mimeType:s.type};return new Promise((c,d)=>{const g=a.put(n);g.onsuccess=()=>{const i=URL.createObjectURL(s);c(i)},g.onerror=i=>{console.error("Error saving to IndexedDB:",i),d(new Error("Failed to save audio to IndexedDB"))}})}catch(t){throw console.error("IndexedDB save error:",t),t}},j=async o=>{try{console.log("Getting audio from IndexedDB with ID:",o);const t=(await F()).transaction([h],"readonly").objectStore(h);return new Promise((r,a)=>{const n=t.get(o);n.onsuccess=()=>{const c=n.result;c?(console.log("Found audio record in IndexedDB:",c.id),r(c.blob)):(console.warn("Audio record not found in IndexedDB:",o),r(null))},n.onerror=c=>{console.error("Error retrieving from IndexedDB:",c),a(new Error("Failed to retrieve audio from IndexedDB"))}})}catch(s){return console.error("IndexedDB get error:",s),null}},$=async(o,s,e)=>{try{const t=await q(s),r=s.type.includes("webm")?"webm":s.type.includes("mp4")?"m4a":s.type.includes("mp3")?"mp3":"audio",a=`${o}/audio/${e}.${r}`;await B.writeFile({path:a,data:t,directory:v.Data,recursive:!0});const n=a;return console.log("Audio saved to filesystem at path:",n),n}catch(t){throw console.error("Filesystem save error:",t),t}},q=o=>new Promise((s,e)=>{const t=new FileReader;t.onloadend=()=>{const a=t.result.split(",")[1];s(a)},t.onerror=e,t.readAsDataURL(o)}),W=async o=>{var s;try{console.log("Reading file from filesystem, original path:",o);let e=o;o.startsWith("file://")&&(e=o.replace(/^file:\/\/\/data\/user\/\d+\/com\.vibewise\.app\/files\//,""));const t=e.match(/([\w-]+\/audio\/[\w.-]+)/);t&&t[1]&&(e=t[1]),console.log("Cleaned path for filesystem read:",e);const r=await B.readFile({path:e,directory:v.Data});console.log("Successfully read file from filesystem");const a=(s=o.split(".").pop())==null?void 0:s.toLowerCase();let n="audio/webm";return a==="mp3"?n="audio/mp3":a==="m4a"&&(n="audio/mp4"),console.log("Using MIME type:",n),V(typeof r.data=="string"?r.data:String(r.data),n)}catch(e){return console.error("Filesystem read error:",e),null}},V=(o,s)=>{const e=atob(o),t=[];for(let r=0;r<e.length;r+=512){const a=e.slice(r,r+512),n=new Array(a.length);for(let d=0;d<a.length;d++)n[d]=a.charCodeAt(d);const c=new Uint8Array(n);t.push(c)}return new Blob(t,{type:s})},z=async(o,s)=>{try{const e=`${Date.now()}-${Math.random().toString(36).substring(2,15)}`;if(console.log("Saving audio with ID:",e),O()){console.log("Detected Capacitor app, saving to filesystem");const r=await $(o.uid,s,e);return console.log("Audio saved to filesystem, path:",r),{success:!0,url:r,localPath:r}}else{console.log("Detected web app, saving to IndexedDB");const t=await N(o.uid,s,e),r=`indexeddb://${h}/${e}`;return console.log("Audio saved to IndexedDB, path:",r,"URL:",t),{success:!0,url:r,localPath:r}}}catch(e){return console.error("Error saving audio locally:",e),{success:!1,error:e}}},H=async o=>{try{if(console.log("Getting audio from local storage, path:",o),o.startsWith("indexeddb://")){console.log("Audio is stored in IndexedDB");const[,s,e]=o.match(/indexeddb:\/\/([^/]+)\/(.+)/)||[];if(!s||!e)throw new Error(`Invalid IndexedDB path: ${o}`);console.log(`Retrieving from IndexedDB - Store: ${s}, Key: ${e}`);const t=await j(e);if(!t)throw new Error(`Audio not found in IndexedDB: ${e}`);const r=URL.createObjectURL(t);return console.log("Created blob URL for IndexedDB audio:",r),{success:!0,url:r}}else{console.log("Audio is stored in Filesystem");const s=o;!o.startsWith("file://")&&!o.includes("/data/user/")&&console.log("Using relative path for Filesystem"),console.log("Retrieving from Filesystem, path:",s);const e=await W(s);if(!e)throw new Error(`Audio not found in Filesystem: ${s}`);const t=URL.createObjectURL(e);return console.log("Created blob URL for Filesystem audio:",t),{success:!0,url:t}}}catch(s){return console.error("Error getting audio from local storage:",s),{success:!1,error:s}}},X=async(o,s)=>{try{const e={...s,type:"reflection",createdAt:new Date().toISOString()},t=p(u,"users",o.uid,"sessions"),r=await R(t,e),a=b(u,"users",o.uid,"private","summary"),n=await E(a);return n.exists()&&await A(a,{latest_reflection_timestamp:s.timestamp,reflection_count:(n.data().reflection_count||0)+1,updatedAt:new Date().toISOString()}),{success:!0,id:r.id}}catch(e){return console.error("Error creating reflection:",e),{success:!1,error:e}}},Y=async(o,s)=>{try{console.log("Starting audio upload process - LOCAL ONLY MODE");const e=await z(o,s);if(e.success&&e.url)return console.log("Successfully saved audio locally:",e.url),{success:!0,url:e.url,storage:"local"};throw console.error("Failed to save audio locally:",e.error),new Error(e.error?String(e.error):"Failed to save audio locally")}catch(e){return console.error("Error storing audio locally:",e),{success:!1,error:e}}},K=async o=>{try{console.log("Analyzing voice tone with input type:",typeof o=="string"?"URL":"Blob");const s=["optimistic","calm","frustrated","anxious","confident","neutral"],e=s[Math.floor(Math.random()*s.length)],t=parseFloat((.7+Math.random()*.3).toFixed(2));return await new Promise(r=>setTimeout(r,1e3)),{success:!0,tone:e,confidence:t}}catch(s){return console.error("Error analyzing voice tone:",s),{success:!1,error:s}}},J=async(o,s)=>{try{const e={...s,type:"balcony",createdAt:new Date().toISOString()},t=p(u,"users",o.uid,"sessions");return{success:!0,id:(await R(t,e)).id}}catch(e){return console.error("Error creating balcony experiment:",e),{success:!1,error:e}}},Z=async(o,s)=>{try{const e={...s,type:"hrv_session",createdAt:new Date().toISOString()},t=p(u,"users",o.uid,"sessions"),r=await R(t,e),a=b(u,"users",o.uid,"private","summary"),n=await E(a);if(n.exists()){const c=new Date;c.setDate(c.getDate()-7);const d=w(p(u,"users",o.uid,"sessions"),m("type","==","hrv_session"),m("timestamp",">=",c.toISOString()),L("timestamp","desc")),g=await x(d);let i=s.avg_rmssd,D=1;g.forEach(f=>{const y=f.data();y.avg_rmssd&&(i+=y.avg_rmssd,D++)});const l=i/D;await A(a,{latest_vibe_score:s.vibe_score,avg_rmssd_7d:l,hrv_session_count:(n.data().hrv_session_count||0)+1,updatedAt:new Date().toISOString()})}return{success:!0,id:r.id}}catch(e){return console.error("Error creating HRV session:",e),{success:!1,error:e}}},ee=async(o,s)=>{try{const e=b(u,"users",o.uid,"sessions",s),t=await E(e);if(t.exists()&&t.data().type==="reflection"){const r=t.data();return r.audio_url&&r.audio_storage==="local"&&console.log("Reflection has locally stored audio:",r.audio_url),{success:!0,reflection:r}}return{success:!1,error:"Reflection not found"}}catch(e){return console.error("Error getting reflection:",e),{success:!1,error:e}}},se=async(o,s={},e=10,t)=>{try{const r=[L("timestamp","desc")];s.types&&s.types.length>0&&r.push(m("type","in",s.types)),s.moodLevel&&r.push(m("mood_level","==",s.moodLevel)),t?r.push(I(e)):r.push(I(e+1));const a=p(u,"users",o.uid,"sessions");let n=w(a,...r);t&&(n=w(n,C(t)));const c=await x(n),d=[];let g;c.forEach(l=>{const f=d.length;if(!t&&f===e)return;g=l;const y=l.data();d.push({...y,id:l.id})});let i=d;if(s.spiralPhase&&(i=i.filter(l=>l.spiral_phase===s.spiralPhase)),s.tags&&s.tags.length>0&&(i=i.filter(l=>{if(l.type!=="reflection")return!1;const f=l;return s.tags.some(y=>f.tags.includes(y))})),s.searchText&&s.searchText.trim()!==""){const l=s.searchText.toLowerCase().trim();i=i.filter(f=>{if(f.type==="reflection")return f.text.toLowerCase().includes(l);if(f.type==="balcony"){const y=f;return y.pattern.toLowerCase().includes(l)||y.truth.toLowerCase().includes(l)}return!1})}const D=!t&&c.size>e;return{success:!0,sessions:i,lastDoc:g,hasMore:D}}catch(r){return console.error("Error getting filtered sessions:",r),{success:!1,error:r}}},te=async o=>{try{const s=w(p(u,"users",o.uid,"sessions"),m("type","==","reflection")),e=await x(s),t=new Set;return e.forEach(r=>{const a=r.data();a.tags&&Array.isArray(a.tags)&&a.tags.forEach(n=>t.add(n))}),{success:!0,tags:Array.from(t).sort()}}catch(s){return console.error("Error getting user tags:",s),{success:!1,error:s}}},oe=async(o,s)=>{try{const e=b(u,"users",o.uid,"sessions",s),t=await E(e);return t.exists()?{success:!0,session:{...t.data(),id:t.id}}:{success:!1,error:"Session not found"}}catch(e){return console.error("Error getting session:",e),{success:!1,error:e}}},re=async(o,s)=>{try{const e=w(p(u,"users",o.uid,"sessions"),m("type","==","balcony"),m("parent_reflection_id","==",s)),t=await x(e);if(!t.empty){const r=t.docs[0];return{success:!0,balcony:{...r.data(),id:r.id}}}return{success:!1,error:"No balcony experiment found for this reflection"}}catch(e){return console.error("Error getting balcony experiment:",e),{success:!1,error:e}}},ne=async(o,s,e)=>{try{const t=b(u,"users",o.uid,"sessions",s);return await A(t,{...e,updatedAt:new Date().toISOString()}),{success:!0}}catch(t){return console.error("Error updating balcony experiment:",t),{success:!1,error:t}}};export{_ as E,re as a,oe as b,J as c,Y as d,X as e,K as f,ee as g,Z as h,te as i,se as j,H as k,ne as u};
