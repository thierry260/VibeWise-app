const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./CMx-lTsZ.js","./DOsK5eWY.js"])))=>i.map(i=>d[i]);
import{g as y,f as i,h as b,q as h,e as f,w as p,i as D,o as A,l as L,d as S,u as R}from"./DxcAzl92.js";import{_ as U}from"./Dp1pzeXC.js";import{r as C}from"./DOsK5eWY.js";var w;(function(s){s.Documents="DOCUMENTS",s.Data="DATA",s.Library="LIBRARY",s.Cache="CACHE",s.External="EXTERNAL",s.ExternalStorage="EXTERNAL_STORAGE"})(w||(w={}));var x;(function(s){s.UTF8="utf8",s.ASCII="ascii",s.UTF16="utf16"})(x||(x={}));const I=C("Filesystem",{web:()=>U(()=>import("./CMx-lTsZ.js"),__vite__mapDeps([0,1]),import.meta.url).then(s=>new s.FilesystemWeb)}),O=()=>typeof window.Capacitor<"u",T="vibewise-local",d="audio-recordings",M=1;let g=null;const _=()=>g||(g=new Promise((s,t)=>{const e=indexedDB.open(T,M);e.onerror=o=>{console.error("Error opening IndexedDB:",o),t(new Error("Could not open IndexedDB"))},e.onsuccess=o=>{s(o.target.result)},e.onupgradeneeded=o=>{const r=o.target.result;r.objectStoreNames.contains(d)||r.createObjectStore(d,{keyPath:"id"})}}),g),$=async(s,t,e)=>{try{const n=(await _()).transaction([d],"readwrite").objectStore(d),a={id:e,userId:s,blob:t,timestamp:Date.now(),mimeType:t.type};return new Promise((c,l)=>{const m=n.put(a);m.onsuccess=()=>{const u=URL.createObjectURL(t);c(u)},m.onerror=u=>{console.error("Error saving to IndexedDB:",u),l(new Error("Failed to save audio to IndexedDB"))}})}catch(o){throw console.error("IndexedDB save error:",o),o}},N=async s=>{try{console.log("Getting audio from IndexedDB with ID:",s);const o=(await _()).transaction([d],"readonly").objectStore(d);return new Promise((r,n)=>{const a=o.get(s);a.onsuccess=()=>{const c=a.result;c?(console.log("Found audio record in IndexedDB:",c.id),r(c.blob)):(console.warn("Audio record not found in IndexedDB:",s),r(null))},a.onerror=c=>{console.error("Error retrieving from IndexedDB:",c),n(new Error("Failed to retrieve audio from IndexedDB"))}})}catch(t){return console.error("IndexedDB get error:",t),null}},P=async(s,t,e)=>{try{const o=await j(t),r=t.type.includes("webm")?"webm":t.type.includes("mp4")?"m4a":t.type.includes("mp3")?"mp3":"audio",n=`${s}/audio/${e}.${r}`;await I.writeFile({path:n,data:o,directory:w.Data,recursive:!0});const a=n;return console.log("Audio saved to filesystem at path:",a),a}catch(o){throw console.error("Filesystem save error:",o),o}},j=s=>new Promise((t,e)=>{const o=new FileReader;o.onloadend=()=>{const n=o.result.split(",")[1];t(n)},o.onerror=e,o.readAsDataURL(s)}),q=async s=>{var t;try{console.log("Reading file from filesystem, original path:",s);let e=s;s.startsWith("file://")&&(e=s.replace(/^file:\/\/\/data\/user\/\d+\/com\.vibewise\.app\/files\//,""));const o=e.match(/([\w-]+\/audio\/[\w.-]+)/);o&&o[1]&&(e=o[1]),console.log("Cleaned path for filesystem read:",e);const r=await I.readFile({path:e,directory:w.Data});console.log("Successfully read file from filesystem");const n=(t=s.split(".").pop())==null?void 0:t.toLowerCase();let a="audio/webm";return n==="mp3"?a="audio/mp3":n==="m4a"&&(a="audio/mp4"),console.log("Using MIME type:",a),V(typeof r.data=="string"?r.data:String(r.data),a)}catch(e){return console.error("Filesystem read error:",e),null}},V=(s,t)=>{const e=atob(s),o=[];for(let r=0;r<e.length;r+=512){const n=e.slice(r,r+512),a=new Array(n.length);for(let l=0;l<n.length;l++)a[l]=n.charCodeAt(l);const c=new Uint8Array(a);o.push(c)}return new Blob(o,{type:t})},W=async(s,t)=>{try{const e=`${Date.now()}-${Math.random().toString(36).substring(2,15)}`;if(console.log("Saving audio with ID:",e),O()){console.log("Detected Capacitor app, saving to filesystem");const r=await P(s.uid,t,e);return console.log("Audio saved to filesystem, path:",r),{success:!0,url:r,localPath:r}}else{console.log("Detected web app, saving to IndexedDB");const o=await $(s.uid,t,e),r=`indexeddb://${d}/${e}`;return console.log("Audio saved to IndexedDB, path:",r,"URL:",o),{success:!0,url:r,localPath:r}}}catch(e){return console.error("Error saving audio locally:",e),{success:!1,error:e}}},Q=async s=>{try{if(console.log("Getting audio from local storage, path:",s),s.startsWith("indexeddb://")){console.log("Audio is stored in IndexedDB");const[,t,e]=s.match(/indexeddb:\/\/([^/]+)\/(.+)/)||[];if(!t||!e)throw new Error(`Invalid IndexedDB path: ${s}`);console.log(`Retrieving from IndexedDB - Store: ${t}, Key: ${e}`);const o=await N(e);if(!o)throw new Error(`Audio not found in IndexedDB: ${e}`);const r=URL.createObjectURL(o);return console.log("Created blob URL for IndexedDB audio:",r),{success:!0,url:r}}else{console.log("Audio is stored in Filesystem");const t=s;!s.startsWith("file://")&&!s.includes("/data/user/")&&console.log("Using relative path for Filesystem"),console.log("Retrieving from Filesystem, path:",t);const e=await q(t);if(!e)throw new Error(`Audio not found in Filesystem: ${t}`);const o=URL.createObjectURL(e);return console.log("Created blob URL for Filesystem audio:",o),{success:!0,url:o}}}catch(t){return console.error("Error getting audio from local storage:",t),{success:!1,error:t}}},k=async(s,t)=>{try{const e={...t,type:"reflection",createdAt:new Date().toISOString()},o=f(i,"users",s.uid,"sessions"),r=await S(o,e),n=y(i,"users",s.uid,"private","summary"),a=await b(n);return a.exists()&&await R(n,{latest_reflection_timestamp:t.timestamp,reflection_count:(a.data().reflection_count||0)+1,updatedAt:new Date().toISOString()}),{success:!0,id:r.id}}catch(e){return console.error("Error creating reflection:",e),{success:!1,error:e}}},X=async(s,t)=>{try{console.log("Starting audio upload process - LOCAL ONLY MODE");const e=await W(s,t);if(e.success&&e.url)return console.log("Successfully saved audio locally:",e.url),{success:!0,url:e.url,storage:"local"};throw console.error("Failed to save audio locally:",e.error),new Error(e.error?String(e.error):"Failed to save audio locally")}catch(e){return console.error("Error storing audio locally:",e),{success:!1,error:e}}},Y=async s=>{try{console.log("Analyzing voice tone with input type:",typeof s=="string"?"URL":"Blob");const t=["optimistic","calm","frustrated","anxious","confident","neutral"],e=t[Math.floor(Math.random()*t.length)],o=parseFloat((.7+Math.random()*.3).toFixed(2));return await new Promise(r=>setTimeout(r,1e3)),{success:!0,tone:e,confidence:o}}catch(t){return console.error("Error analyzing voice tone:",t),{success:!1,error:t}}},K=async(s,t)=>{try{const e={...t,type:"balcony",createdAt:new Date().toISOString()},o=f(i,"users",s.uid,"sessions");return{success:!0,id:(await S(o,e)).id}}catch(e){return console.error("Error creating balcony experiment:",e),{success:!1,error:e}}},J=async(s,t)=>{try{const e={...t,type:"hrv_session",createdAt:new Date().toISOString()},o=f(i,"users",s.uid,"sessions"),r=await S(o,e),n=y(i,"users",s.uid,"private","summary"),a=await b(n);if(a.exists()){const c=new Date;c.setDate(c.getDate()-7);const l=h(f(i,"users",s.uid,"sessions"),p("type","==","hrv_session"),p("timestamp",">=",c.toISOString()),A("timestamp","desc")),m=await D(l);let u=t.avg_rmssd,v=1;m.forEach(F=>{const E=F.data();E.avg_rmssd&&(u+=E.avg_rmssd,v++)});const B=u/v;await R(n,{latest_vibe_score:t.vibe_score,avg_rmssd_7d:B,hrv_session_count:(a.data().hrv_session_count||0)+1,updatedAt:new Date().toISOString()})}return{success:!0,id:r.id}}catch(e){return console.error("Error creating HRV session:",e),{success:!1,error:e}}},Z=async(s,t)=>{try{const e=y(i,"users",s.uid,"sessions",t),o=await b(e);if(o.exists()&&o.data().type==="reflection"){const r=o.data();return r.audio_url&&r.audio_storage==="local"&&console.log("Reflection has locally stored audio:",r.audio_url),{success:!0,reflection:r}}return{success:!1,error:"Reflection not found"}}catch(e){return console.error("Error getting reflection:",e),{success:!1,error:e}}},ee=async(s,t=10)=>{try{const e=h(f(i,"users",s.uid,"sessions"),A("timestamp","desc"),L(t)),o=await D(e),r=[];return o.forEach(n=>{const a=n.data();r.push({...a,id:n.id})}),{success:!0,sessions:r}}catch(e){return console.error("Error getting recent sessions:",e),{success:!1,error:e}}},se=async(s,t)=>{try{const e=y(i,"users",s.uid,"sessions",t),o=await b(e);return o.exists()?{success:!0,session:{...o.data(),id:o.id}}:{success:!1,error:"Session not found"}}catch(e){return console.error("Error getting session:",e),{success:!1,error:e}}},oe=async(s,t)=>{try{const e=h(f(i,"users",s.uid,"sessions"),p("type","==","balcony"),p("parent_reflection_id","==",t)),o=await D(e);if(!o.empty){const r=o.docs[0];return{success:!0,balcony:{...r.data(),id:r.id}}}return{success:!1,error:"No balcony experiment found for this reflection"}}catch(e){return console.error("Error getting balcony experiment:",e),{success:!1,error:e}}},te=async(s,t,e)=>{try{const o=y(i,"users",s.uid,"sessions",t);return await R(o,{...e,updatedAt:new Date().toISOString()}),{success:!0}}catch(o){return console.error("Error updating balcony experiment:",o),{success:!1,error:o}}};export{x as E,oe as a,ee as b,K as c,se as d,X as e,k as f,Z as g,Y as h,J as i,Q as j,te as u};
